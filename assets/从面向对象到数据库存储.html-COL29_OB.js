import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as n,o as a}from"./app-jJyUj3kv.js";const r={};function i(l,t){return a(),o("div",null,t[0]||(t[0]=[n('<h1 id="从面向对象到数据库存储" tabindex="-1"><a class="header-anchor" href="#从面向对象到数据库存储"><span>从面向对象到数据库存储</span></a></h1><h2 id="继承关系的存储" tabindex="-1"><a class="header-anchor" href="#继承关系的存储"><span>继承关系的存储</span></a></h2><p>对于继承关系，我们一般有两种存储方式：</p><ol><li><strong>合并存储</strong>：将所有子类和父类的字段都存储在一张表中，不同子类建立不同表。</li></ol><p>比如，B、C继承A。那么 B建立一张表，C建立一张表。B表和C表都存储A表的数据。 然后B表存储自己独特的字段，C表存储自己独特的字段。</p><p>这样做的好处是，查询方便，不用做表关联，插入删除也方便。</p><ol start="2"><li><strong>分开存储</strong>：将父类和子类分别存储在不同的表中，子表通过外键关联父表。</li></ol><p>比如，B、C继承A。那么三个类分成三个表，每张表存储自己独特的字段。然后B表和C表通过外键关联A表。 这样做查询时需要建立表的链接，比较费时，而且插入删除时需要多表操作比较麻烦。 但是假如一般类也可以生成对象，那么这种方法比较合适。</p><h2 id="聚合关系的存储" tabindex="-1"><a class="header-anchor" href="#聚合关系的存储"><span>聚合关系的存储</span></a></h2><p>对于聚合关系，我们有以下集中存储方式：</p><ol><li><p><strong>一对一关系</strong>：可以存成两张表，通过外键关联。但更多的是存成一张表，这样减少开销</p></li><li><p><strong>一对多关系</strong>：一般存成两张表，通过外键关联。当然也可以化简成一张表（往多端靠拢）。</p></li><li><p><strong>多对多关系</strong>：一般存成三张表，通过外键关联。或者耍流氓存向量或者json，但是这样就违背了关系型数据库的设计理念。</p></li></ol>',11)]))}const c=e(r,[["render",i],["__file","从面向对象到数据库存储.html.vue"]]),d=JSON.parse('{"path":"/technology/backend/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8.html","title":"从面向对象到数据库存储","lang":"zh-CN","frontmatter":{"icon":"fa-solid fa-database","date":"2024-11-26T00:00:00.000Z","category":["数据库"],"tag":["数据库设计","面向对象"],"description":"从面向对象到数据库存储 继承关系的存储 对于继承关系，我们一般有两种存储方式： 合并存储：将所有子类和父类的字段都存储在一张表中，不同子类建立不同表。 比如，B、C继承A。那么 B建立一张表，C建立一张表。B表和C表都存储A表的数据。 然后B表存储自己独特的字段，C表存储自己独特的字段。 这样做的好处是，查询方便，不用做表关联，插入删除也方便。 分开存...","head":[["meta",{"property":"og:url","content":"https://18259008878.github.io/painlife/painlife/technology/backend/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8.html"}],["meta",{"property":"og:site_name","content":"\\"极乐\\"人生"}],["meta",{"property":"og:title","content":"从面向对象到数据库存储"}],["meta",{"property":"og:description","content":"从面向对象到数据库存储 继承关系的存储 对于继承关系，我们一般有两种存储方式： 合并存储：将所有子类和父类的字段都存储在一张表中，不同子类建立不同表。 比如，B、C继承A。那么 B建立一张表，C建立一张表。B表和C表都存储A表的数据。 然后B表存储自己独特的字段，C表存储自己独特的字段。 这样做的好处是，查询方便，不用做表关联，插入删除也方便。 分开存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-27T00:55:35.000Z"}],["meta",{"property":"article:tag","content":"数据库设计"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:published_time","content":"2024-11-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-27T00:55:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"从面向对象到数据库存储\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-27T00:55:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Carmen\\",\\"url\\":\\"https://gitee.com/Q_of_Git\\"}]}"]]},"headers":[{"level":2,"title":"继承关系的存储","slug":"继承关系的存储","link":"#继承关系的存储","children":[]},{"level":2,"title":"聚合关系的存储","slug":"聚合关系的存储","link":"#聚合关系的存储","children":[]}],"git":{"createdTime":1732610235000,"updatedTime":1732668935000,"contributors":[{"name":"Carmen","email":"2942173241@qq.com","commits":2}]},"readingTime":{"minutes":1.5,"words":450},"filePathRelative":"technology/backend/从面向对象到数据库存储.md","localizedDate":"2024年11月26日","excerpt":"\\n<h2>继承关系的存储</h2>\\n<p>对于继承关系，我们一般有两种存储方式：</p>\\n<ol>\\n<li><strong>合并存储</strong>：将所有子类和父类的字段都存储在一张表中，不同子类建立不同表。</li>\\n</ol>\\n<p>比如，B、C继承A。那么 B建立一张表，C建立一张表。B表和C表都存储A表的数据。\\n然后B表存储自己独特的字段，C表存储自己独特的字段。</p>\\n<p>这样做的好处是，查询方便，不用做表关联，插入删除也方便。</p>\\n<ol start=\\"2\\">\\n<li><strong>分开存储</strong>：将父类和子类分别存储在不同的表中，子表通过外键关联父表。</li>\\n</ol>","autoDesc":true}');export{c as comp,d as data};
